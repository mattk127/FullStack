"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestSchemaPreprocessor = void 0;
const ajv_1 = require("../../framework/ajv");
const httpMethods = new Set([
    'get',
    'put',
    'post',
    'delete',
    'options',
    'head',
    'patch',
    'trace',
]);
class RequestSchemaPreprocessor {
    constructor(apiDoc, options) {
        this.ajv = ajv_1.createRequestAjv(apiDoc, options);
        this.apiDoc = apiDoc;
    }
    preProcess() {
        const paths = Object.keys(this.apiDoc.paths);
        paths.forEach((p) => {
            const piOrRef = this.apiDoc.paths[p];
            const pathItem = piOrRef.$ref
                ? this.ajv.getSchema(piOrRef.$ref).schema
                : piOrRef;
            for (const pathItemKey of Object.keys(pathItem)) {
                if (httpMethods.has(pathItemKey)) {
                    this.preprocessRequestBody(pathItemKey, pathItem);
                    this.preprocessPathLevelParameters(pathItemKey, pathItem);
                }
            }
        });
    }
    preprocessRequestBody(pathItemKey, pathItem) {
        var _a, _b;
        const v = pathItem[pathItemKey];
        const ref = (_a = v === null || v === void 0 ? void 0 : v.requestBody) === null || _a === void 0 ? void 0 : _a.$ref;
        const requestBody = ((ref ? (_b = this.ajv.getSchema(ref)) === null || _b === void 0 ? void 0 : _b.schema : v.requestBody));
        if (!(requestBody === null || requestBody === void 0 ? void 0 : requestBody.content))
            return;
        const contentEntries = Object.entries(requestBody.content);
        for (const [_, mediaTypeObject] of contentEntries) {
            this.cleanseContentSchema(mediaTypeObject);
            this.handleDiscriminator(mediaTypeObject);
        }
    }
    preprocessPathLevelParameters(pathItemKey, pathItem) {
        var _a, _b, _c;
        const parameters = (_a = pathItem.parameters) !== null && _a !== void 0 ? _a : [];
        if (parameters.length === 0)
            return;
        let v = pathItem[pathItemKey];
        if (v === parameters)
            return;
        const ref = (_b = v === null || v === void 0 ? void 0 : v.parameters) === null || _b === void 0 ? void 0 : _b.$ref;
        const op = ref && ((_c = this.ajv.getSchema(ref)) === null || _c === void 0 ? void 0 : _c.schema);
        if (op)
            v = op;
        v.parameters = v.parameters || [];
        for (const param of parameters) {
            v.parameters.push(param);
        }
    }
    cleanseContentSchema(content) {
        // remove required if readonly
        const removeRequiredForReadOnly = (prop, schema) => {
            const propertyValue = schema.properties[prop];
            const required = schema.required;
            if (propertyValue.readOnly && required) {
                const index = required.indexOf(prop);
                if (index > -1) {
                    schema.required = required
                        .slice(0, index)
                        .concat(required.slice(index + 1));
                    if (schema.required.length === 0) {
                        delete schema.required;
                    }
                }
            }
        };
        // traverse schema
        this.traverse(content.schema, removeRequiredForReadOnly);
        return content.schema;
    }
    handleDiscriminator(content) {
        var _a;
        const schemaObj = content.schema.hasOwnProperty('$ref')
            ? (_a = this.ajv.getSchema(content.schema['$ref'])) === null || _a === void 0 ? void 0 : _a.schema
            : content.schema;
        if (schemaObj.discriminator) {
            this.discriminatorTraverse(null, schemaObj, {});
        }
    }
    discriminatorTraverse(parent, schema, o = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const schemaObj = schema.hasOwnProperty('$ref')
            ? (_a = this.ajv.getSchema(schema['$ref'])) === null || _a === void 0 ? void 0 : _a.schema
            : schema;
        const xOf = schemaObj.oneOf ? 'oneOf' : 'anyOf';
        if (((_b = schemaObj === null || schemaObj === void 0 ? void 0 : schemaObj.discriminator) === null || _b === void 0 ? void 0 : _b.propertyName) && !o.discriminator) {
            // TODO discriminator can be used for anyOf too!
            const options = schemaObj[xOf].map((refObject) => {
                const option = this.findKey(schemaObj.discriminator.mapping, (value) => value === refObject['$ref']);
                const ref = this.getKeyFromRef(refObject['$ref']);
                return { option: option || ref, ref };
            });
            o.options = options;
            o.discriminator = (_c = schemaObj.discriminator) === null || _c === void 0 ? void 0 : _c.propertyName;
        }
        o.properties = Object.assign(Object.assign({}, ((_d = o.properties) !== null && _d !== void 0 ? _d : {})), ((_e = schemaObj.properties) !== null && _e !== void 0 ? _e : {}));
        o.required = Array.from(new Set(((_f = o.required) !== null && _f !== void 0 ? _f : []).concat((_g = schemaObj.required) !== null && _g !== void 0 ? _g : [])));
        if (schemaObj[xOf]) {
            schemaObj[xOf].forEach((s) => this.discriminatorTraverse(schemaObj, s, o));
        }
        else if (schemaObj) {
            const ancestor = parent;
            const option = this.findKey((_h = ancestor.discriminator) === null || _h === void 0 ? void 0 : _h.mapping, (value) => value === schema['$ref']) || this.getKeyFromRef(schema['$ref']);
            if (option) {
                const newSchema = JSON.parse(JSON.stringify(schemaObj));
                newSchema.properties = Object.assign(Object.assign({}, ((_j = o.properties) !== null && _j !== void 0 ? _j : {})), ((_k = newSchema.properties) !== null && _k !== void 0 ? _k : {}));
                newSchema.required = o.required;
                if (newSchema.required.length === 0) {
                    delete newSchema.required;
                }
                (_l = ancestor._discriminator) !== null && _l !== void 0 ? _l : (ancestor._discriminator = {
                    validators: {},
                    options: o.options,
                    property: o.discriminator,
                });
                ancestor._discriminator.validators[option] = this.ajv.compile(newSchema);
            }
            //reset data
            o.properties = {};
            delete o.required;
        }
    }
    traverse(schema, f) {
        var _a;
        const schemaObj = schema.hasOwnProperty('$ref')
            ? (_a = this.ajv.getSchema(schema['$ref'])) === null || _a === void 0 ? void 0 : _a.schema
            : schema;
        if (schemaObj.allOf) {
            schemaObj.allOf.forEach((s) => this.traverse(s, f));
        }
        else if (schemaObj.oneOf) {
            schemaObj.oneOf.forEach((s) => this.traverse(s, f));
        }
        else if (schemaObj.anyOf) {
            schemaObj.anyOf.forEach((s) => this.traverse(s, f));
        }
        else if (schemaObj.properties) {
            Object.keys(schemaObj.properties).forEach((prop) => {
                f(prop, schemaObj);
            });
        }
    }
    findKey(object, searchFunc) {
        if (!object) {
            return;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            if (searchFunc(object[keys[i]])) {
                return keys[i];
            }
        }
    }
    getKeyFromRef(ref) {
        return ref.split('/components/schemas/')[1];
    }
}
exports.RequestSchemaPreprocessor = RequestSchemaPreprocessor;
//# sourceMappingURL=request.schema.preprocessor.js.map