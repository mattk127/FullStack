"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BodySchemaParser = void 0;
const types_1 = require("../../framework/types");
class BodySchemaParser {
    constructor(ajv, apiDoc) {
        this.ajv = ajv;
        this._apiDoc = apiDoc;
    }
    parse(path, pathSchema, contentType) {
        // TODO should return OpenAPIV3.SchemaObject instead
        let schemaRequestBody = pathSchema.requestBody;
        if (schemaRequestBody === null || schemaRequestBody === void 0 ? void 0 : schemaRequestBody.hasOwnProperty('$ref')) {
            // TODO use ajv.getSchema instead
            const ref = schemaRequestBody.$ref;
            const id = ref.replace(/^.+\//i, '');
            schemaRequestBody = this._apiDoc.components.requestBodies[id];
        }
        const requestBody = schemaRequestBody;
        if (requestBody === null || requestBody === void 0 ? void 0 : requestBody.hasOwnProperty('content')) {
            return this.toSchema(path, contentType, requestBody);
        }
        return {};
    }
    toSchema(path, contentType, requestBody) {
        var _a;
        if (!(requestBody === null || requestBody === void 0 ? void 0 : requestBody.content))
            return {};
        let content = null;
        for (const type of contentType.equivalents()) {
            content = requestBody.content[type];
            if (content)
                break;
        }
        if (!content) {
            for (const requestContentType of Object.keys(requestBody.content)
                .sort()
                .reverse()) {
                if (requestContentType === '*/*') {
                    content = requestBody.content[requestContentType];
                    break;
                }
                if (!new RegExp(/^[a-z]+\/\*$/).test(requestContentType))
                    continue; // not a wildcard of type application/*
                const [type] = requestContentType.split('/', 1);
                if (new RegExp(`^${type}\/.+$`).test(contentType.contentType)) {
                    content = requestBody.content[requestContentType];
                    break;
                }
            }
        }
        if (!content) {
            const msg = contentType.contentType === 'not_provided'
                ? 'media type not specified'
                : `unsupported media type ${contentType.contentType}`;
            throw new types_1.UnsupportedMediaType({ path: path, message: msg });
        }
        return (_a = content.schema) !== null && _a !== void 0 ? _a : {};
    }
}
exports.BodySchemaParser = BodySchemaParser;
//# sourceMappingURL=body.parse.js.map